import{Vector3 as t,Mesh as e,SphereGeometry as i,MeshBasicMaterial as n,Quaternion as s,PlaneGeometry as o,CylinderGeometry as r,Object3D as a,Color as l,InstancedMesh as h,Group as c}from"three";const p={velocity:.1,maxStretch:.1},g=new t,d=new t,u=new e(new i(.03),new n({transparent:!0}));class f{constructor(e,i={},n=!1){this.options={...p,...i};const o=e.clone();e.parent.add(o),o.add(e),this.target=e,this.targetHelper=u.clone(),i.scene&&i.scene.add(this.targetHelper),this.currentHelper=u.clone(),i.scene&&i.scene.add(this.currentHelper),this.currentHelper.add(u.clone()),this.currentHelper.children[0].position.y=-.1,this._isFirstStep=!0,this.originPosition=e.position.clone(),this.originRotation=e.rotation.clone(),this.oldBoneWorldPosition=new t,this.oldBoneWorldRotation=new s,this.target.getWorldPosition(this.oldBoneWorldPosition),this.target.getWorldQuaternion(this.oldBoneWorldRotation),this.restLength=this.target.parent.position.length()}reset(){this._isFirstStep=!0,this.target.position.copy(this.originPosition),this.target.rotation.copy(this.originRotation),this.target.updateMatrixWorld(!0,!1),this.target.getWorldPosition(this.oldBoneWorldPosition)}dispose(){this.reset();const t=this.target.parent,e=t.parent;e.remove(t),e.add(this.target)}update(t=null){if(!t)if(this.ms){const e=performance.now();t=e-this.ms,t/=1e3,this.ms=e}else this.ms=performance.now(),t=.016;let e=1;if((t=Math.min(t,100))>.01&&(e=2),t>=100&&(e=25),!(t<.006))for(let t=0;t<e;t++)this.step(.0085*100)}step(t){this.target.parent.updateMatrixWorld(!0,!1),this.targetHelper.position.copy(this.originPosition),this.target.parent.localToWorld(this.targetHelper.position),this._isFirstStep&&(this._isFirstStep=!1,this.oldBoneWorldPosition.copy(this.targetHelper.position)),g.copy(this.oldBoneWorldPosition).lerp(this.targetHelper.position,Math.min(this.options.velocity*t,.99999)),this.target.position.copy(g),this.target.parent.worldToLocal(this.target.position),this.oldBoneWorldPosition.copy(g);const e=this.target.parent.getWorldPosition(d);this.currentHelper.position.copy(g),this.currentHelper.updateMatrixWorld(!0,!1),this.currentHelper.lookAt(e);const i=this.target.position.clone();i.normalize(),this.target.up.set(0,1,0),this.target.quaternion.setFromUnitVectors(this.target.up,i),this.target.position.set(0,0,0),this.target.updateMatrix()}}
/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */function _(t,e){if(!t)throw new Error(e)}function m(t,e){return null!=t?t:e}
/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */class v{static MAX_DELTA_TIME_MS=1/60*1e3*4;_listeners=[];_currentAnimationStep=0;_currentTime=0;_springTime=0;_currentValue=0;_currentVelocity=0;_isAnimating=!1;_oscillationVelocityPairs=[];constructor(t={}){this._config={fromValue:m(t.fromValue,0),toValue:m(t.toValue,1),stiffness:m(t.stiffness,100),damping:m(t.damping,10),mass:m(t.mass,1),initialVelocity:m(t.initialVelocity,0),overshootClamping:m(t.overshootClamping,!1),allowsOverdamping:m(t.allowsOverdamping,!1),restVelocityThreshold:m(t.restVelocityThreshold,.001),restDisplacementThreshold:m(t.restDisplacementThreshold,1e-4),maxVelocity:m(t.maxVelocity,1/0)},this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}start(){const{fromValue:t,toValue:e,initialVelocity:i}=this._config;return t===e&&0===i||(this._reset(),this._isAnimating=!0),this}stop(){return this._isAnimating?(this._isAnimating=!1,this._notifyListeners("onStop"),this._currentAnimationStep&&(cancelAnimationFrame(this._currentAnimationStep),this._currentAnimationStep=0),this):this}get currentValue(){return this._currentValue}get currentVelocity(){return this._currentVelocity}get isAtRest(){return this._isSpringAtRest()}get isAnimating(){return this._isAnimating}updateConfig(t){this._advanceSpringToTime(Date.now());const e={fromValue:this._currentValue,initialVelocity:this._currentVelocity};return this._config={...this._config,...e,...t},this._reset(),this}onStart(t){return this._listeners.push({onStart:t}),this}onUpdate(t){return this._listeners.push({onUpdate:t}),this}onStop(t){return this._listeners.push({onStop:t}),this}removeListener(t){return this._listeners=this._listeners.reduce(((e,i)=>(-1!==Object.values(i).indexOf(t)||e.push(i),e)),[]),this}removeAllListeners(){return this._listeners=[],this}_reset(){this._currentTime=Date.now(),this._springTime=0,this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}_notifyListeners(t){this._listeners.forEach((e=>{const i=e[t];"function"==typeof i&&i(this)}))}_step(t){this._advanceSpringToTime(t,!0)}_advanceSpringToTime(t,e=!1){if(!this._isAnimating)return;let i=t-this._currentTime;i>v.MAX_DELTA_TIME_MS&&(i=v.MAX_DELTA_TIME_MS),this._springTime+=i;const n=this._config.damping,s=this._config.mass,o=this._config.stiffness,r=this._config.fromValue,a=this._config.toValue,l=-this._config.initialVelocity,h=this._config.maxVelocity;_(s>0,"Mass value must be greater than 0"),_(o>0,"Stiffness value must be greater than 0");let c=n/(2*Math.sqrt(o*s));const p=Math.sqrt(o/s)/1e3,g=p*Math.sqrt(1-c*c),d=p*Math.sqrt(c*c-1),u=a-r;c>1&&!this._config.allowsOverdamping&&(c=1);let f=0,m=0;const x=this._springTime;if(c<1){const t=Math.exp(-c*p*x);f=a-t*((l+c*p*u)/g*Math.sin(g*x)+u*Math.cos(g*x)),m=c*p*t*(Math.sin(g*x)*(l+c*p*u)/g+u*Math.cos(g*x))-t*(Math.cos(g*x)*(l+c*p*u)-g*u*Math.sin(g*x))}else if(1===c){const t=Math.exp(-p*x);f=a-t*(u+(l+p*u)*x),m=t*(l*(x*p-1)+x*u*(p*p))}else{const t=Math.exp(-c*p*x);f=a-t*((l+c*p*u)*Math.sinh(d*x)+d*u*Math.cosh(d*x))/d,m=t*c*p*(Math.sinh(d*x)*(l+c*p*u)+u*d*Math.cosh(d*x))/d-t*(d*Math.cosh(d*x)*(l+c*p*u)+d*d*u*Math.sinh(d*x))/d}return m=Math.max(-h,Math.min(h,m)),this._currentTime=t,this._currentValue=f,this._currentVelocity=m,e&&(this._notifyListeners("onUpdate"),this._isAnimating)&&(this._isSpringOvershooting()||this._isSpringAtRest())?(0!==o&&(this._currentValue=a,this._currentVelocity=0,this._notifyListeners("onUpdate")),void this.stop()):void 0}_isSpringOvershooting(){const{stiffness:t,fromValue:e,toValue:i,overshootClamping:n}=this._config;let s=!1;return n&&0!==t&&(s=e<i?this._currentValue>i:this._currentValue<i),s}_isSpringAtRest(){const{stiffness:t,toValue:e,restDisplacementThreshold:i,restVelocityThreshold:n}=this._config,s=Math.abs(this._currentVelocity)<=n;return 0!==t&&Math.abs(e-this._currentValue)<=i&&s}}const x={stiffness:500,damping:17},w=new t,y=new t,M=new e(new i(.03),new n({transparent:!0}));class V{constructor(e,i={}){this.options={...x,...i};const n=e.clone();e.parent.add(n),n.add(e),this.target=e,this.targetHelper=M.clone(),i.scene&&i.scene.add(this.targetHelper),this.currentHelper=M.clone(),i.scene&&i.scene.add(this.currentHelper),this.currentHelper.add(M.clone()),this.currentHelper.children[0].position.y=-.1,this._isFirstStep=!0;const o={stiffness:this.options.stiffness,damping:this.options.damping};this.springX=new v({fromValue:0,toValue:0,...o}),this.springY=new v({fromValue:0,toValue:0,...o}),this.springZ=new v({fromValue:0,toValue:0,...o}),this.originPosition=e.position.clone(),this.originRotation=e.rotation.clone(),this.oldBoneWorldPosition=new t,this.oldBoneWorldRotation=new s,this.target.getWorldPosition(this.oldBoneWorldPosition),this.target.getWorldQuaternion(this.oldBoneWorldRotation),this.restLength=this.target.parent.position.length(),this.reset()}reset(){this._isFirstStep=!0,this.target.position.copy(this.originPosition),this.target.rotation.copy(this.originRotation),this.target.updateMatrixWorld(!0,!1),this.target.getWorldPosition(this.oldBoneWorldPosition)}dispose(){this.reset();const t=this.target.parent,e=t.parent;e.remove(t),e.add(this.target)}update(t=null){if(!t)if(this.ms){const e=performance.now();t=e-this.ms,t/=1e3,this.ms=e}else this.ms=performance.now(),t=.016;let e=1;if((t=Math.min(t,100))>.01&&(e=2),t>=100&&(e=25),!(t<.006))for(let t=0;t<e;t++)this.step(.0085*100)}step(t){this.target.parent.updateMatrixWorld(!0,!1),this.targetHelper.position.copy(this.originPosition),this.target.parent.localToWorld(this.targetHelper.position),this._isFirstStep&&(this._isFirstStep=!1,this.springX.updateConfig({fromValue:this.targetHelper.position.x}),this.springY.updateConfig({fromValue:this.targetHelper.position.y}),this.springZ.updateConfig({fromValue:this.targetHelper.position.z})),this.springX.updateConfig({toValue:this.targetHelper.position.x}).start(),this.springY.updateConfig({toValue:this.targetHelper.position.y}).start(),this.springZ.updateConfig({toValue:this.targetHelper.position.z}).start();const e=Date.now();this.springX._step(e),this.springY._step(e),this.springZ._step(e),this.target.position.set(this.springX.currentValue,this.springY.currentValue,this.springZ.currentValue),this.target.parent.worldToLocal(this.target.position),this.oldBoneWorldPosition.copy(w);const i=this.target.parent.getWorldPosition(y);this.currentHelper.position.copy(w),this.currentHelper.updateMatrixWorld(!0,!1),this.currentHelper.lookAt(i);const n=this.target.position.clone();n.normalize(),this.target.up.set(0,1,0),this.target.quaternion.setFromUnitVectors(this.target.up,n),this.target.position.set(0,0,0),this.target.updateMatrix()}}class B{constructor(t,{multiplier:e=1}={}){this.wiggleBones=[],t.bones.forEach((t=>{t.userData.wiggleVelocity?this.wiggleBones.push(new f(t,{velocity:t.userData.wiggleVelocity*e})):t.userData.wiggleStiffness&&this.wiggleBones.push(new V(t,{stiffness:t.userData.wiggleStiffness,damping:t.userData.wiggleDamping}))}))}reset(){this.wiggleBones.forEach((t=>t.reset()))}dispose(){this.wiggleBones.forEach((t=>t.dispose())),this.wiggleBones=[]}update(t){if(!t)if(this.ms){const e=performance.now();t=e-this.ms,t/=1e3,this.ms=e}else this.ms=performance.now(),t=.016;this.wiggleBones.forEach((e=>e.update(t)))}}const S=new o,W=new r(1,1,1);W.rotateX(Math.PI/2);const A=new a,T=new t,H=new t,P=new l("red");class E extends a{constructor({skeleton:e=null,dotSize:i=.33,lineWidth:s=.025,colorStatic:o="#006CFF",colorDynamic:r="#FC7229",extraBoneMultiplier:a=1}={}){if(super(),!e)return console.log("Failed to create WiggleRigHelper: missing skeleton on initialization");this.links=e.bones.reduce(((t,e)=>(e.children.forEach((i=>t.push([e,i]))),t)),[]),this.finalBones=e.bones.filter((t=>0===t.children.length)),this.finalBoneLengths=this.finalBones.map((t=>t.position.length())),this.finalBoneExtensionPositions=this.finalBones.map((()=>new t)),this.dots=new h(S,new b({color:16777215,transparent:!0,depthTest:!1}),e.bones.length+this.finalBoneLengths.length),this.dots.renderOrder=999,this.dots.frustumCulled=!1;for(let t=0;t<e.bones.length+this.finalBones.length;t++)P.setStyle(0===t?o:r),this.dots.setColorAt(t,P);this.add(this.dots),this.dots.onBeforeRender=(t,n,s)=>{e.bones.forEach(((t,e)=>{const n=t.getWorldPosition(T);A.position.copy(n),A.scale.setScalar(i),A.rotation.copy(s.rotation),A.updateMatrix(),this.dots.setMatrixAt(e,A.matrix)})),this.finalBones.forEach(((t,n)=>{T.set(0,this.finalBoneLengths[0]*a,0);const o=t.localToWorld(T);this.finalBoneExtensionPositions[n].copy(o),A.position.copy(o),A.scale.setScalar(i),A.rotation.copy(s.rotation),A.updateMatrix(),this.dots.setMatrixAt(e.bones.length+n,A.matrix)})),this.dots.instanceMatrix.needsUpdate=!0,this.dots.computeBoundingSphere()},this.lines=new h(W,new n({color:r,transparent:!0,depthTest:!1}),this.links.length+this.finalBones.length),A.scale.set(0,0,0),A.updateMatrix();for(let t=0;t<this.links.length+this.finalBones.length;t++)this.lines.setMatrixAt(t,A.matrix);this.lines.renderOrder=998,this.lines.frustumCulled=!1,this.add(this.lines),this.lines.onBeforeRender=()=>{this.links.forEach((([t,e],i)=>{const n=t.getWorldPosition(T),o=e.getWorldPosition(H);A.position.copy(n).lerp(o,.5),A.scale.set(s,s,n.distanceTo(o)),A.lookAt(n),A.updateMatrix(),this.lines.setMatrixAt(i,A.matrix)})),this.finalBones.forEach(((t,e)=>{const i=t.getWorldPosition(T),n=this.finalBoneExtensionPositions[e];A.position.copy(i).lerp(n,.5),A.scale.set(s,s,i.distanceTo(n)),A.lookAt(i),A.updateMatrix(),this.lines.setMatrixAt(this.links.length+e,A.matrix)})),this.lines.instanceMatrix.needsUpdate=!0,this.lines.computeBoundingSphere()}}dispose(){super.dispose()}}class b extends n{constructor(t){super(t),this.type="WiggleBonesHelperDotMaterial",this.vertexShader="\n            #include <common>\n            #include <batching_pars_vertex>\n            #include <uv_pars_vertex>\n            #include <envmap_pars_vertex>\n            #include <color_pars_vertex>\n            #include <fog_pars_vertex>\n            #include <morphtarget_pars_vertex>\n            #include <skinning_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n            #include <clipping_planes_pars_vertex>\n            varying vec2 vvUv;\n            void main() {\n                #include <uv_vertex>\n                #include <color_vertex>\n                #include <morphcolor_vertex>\n                #include <batching_vertex>\n                #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n                    #include <beginnormal_vertex>\n                    #include <morphnormal_vertex>\n                    #include <skinbase_vertex>\n                    #include <skinnormal_vertex>\n                    #include <defaultnormal_vertex>\n                #endif\n                #include <begin_vertex>\n                #include <morphtarget_vertex>\n                #include <skinning_vertex>\n                #include <project_vertex>\n                #include <logdepthbuf_vertex>\n                #include <clipping_planes_vertex>\n                #include <worldpos_vertex>\n                #include <envmap_vertex>\n                #include <fog_vertex>\n\n                vvUv = uv;\n            }\n        ",this.fragmentShader="\n            uniform vec3 diffuse;\n            uniform float opacity;\n            #ifndef FLAT_SHADED\n            varying vec3 vNormal;\n            #endif\n            #include <common>\n            #include <dithering_pars_fragment>\n            #include <color_pars_fragment>\n            #include <uv_pars_fragment>\n            #include <map_pars_fragment>\n            #include <alphamap_pars_fragment>\n            #include <alphatest_pars_fragment>\n            #include <alphahash_pars_fragment>\n            #include <aomap_pars_fragment>\n            #include <lightmap_pars_fragment>\n            #include <envmap_common_pars_fragment>\n            #include <envmap_pars_fragment>\n            #include <fog_pars_fragment>\n            #include <specularmap_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n            #include <clipping_planes_pars_fragment>\n            varying vec2 vvUv;\n            void main() {\n                vec4 diffuseColor = vec4( diffuse, opacity );\n                #include <clipping_planes_fragment>\n                #include <logdepthbuf_fragment>\n                #include <map_fragment>\n                #include <color_fragment>\n                #include <alphamap_fragment>\n                #include <alphatest_fragment>\n                #include <alphahash_fragment>\n                #include <specularmap_fragment>\n                ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n                #ifdef USE_LIGHTMAP\n                    vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n                    reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n                #else\n                    reflectedLight.indirectDiffuse += vec3( 1.0 );\n                #endif\n                #include <aomap_fragment>\n                reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n                vec3 outgoingLight = reflectedLight.indirectDiffuse;\n                #include <envmap_fragment>\n                #include <opaque_fragment>\n\n                float circ = length(vvUv - vec2(0.5)) * 1.5;\n                gl_FragColor.a = smoothstep(0.5, 0.48, circ);\n                gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0), smoothstep(0.35, 0.37, circ));\n                gl_FragColor.rgb = mix(vec3(0.0), gl_FragColor.rgb, gl_FragColor.a);\n\n                gl_FragColor.a += smoothstep(0.75, 0.5, circ) * 0.15;\n                gl_FragColor.a = clamp(gl_FragColor.a, 0.0, 1.0);\n                // gl_FragColor.a *= 0.9;\n\n\n                #include <tonemapping_fragment>\n                #include <colorspace_fragment>\n                #include <fog_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n            }\n        "}}class C extends c{constructor(t,e=null){super(),this.skeleton=t,this.wiggleBones=[],this.multiplier=1,this.setting=e||null,this.addStructure()}getBoneName(){this.skeleton.bones.forEach(((t,e)=>{console.log(t.name,e)}))}addStructure(){let t;this.skeleton.bones.forEach(((e,i)=>{null===this.setting?0===i?this.rootBone=e:this.wiggleBones.push(new f(e,{velocity:.1,maxStretch:.1})):(t=this.setting[e.name],t&&(t.root?this.rootBone=e:t.velocity?this.wiggleBones.push(new f(e,t)):t.stiffness&&this.wiggleBones.push(new V(e,t))))}))}reset(){this.wiggleBones.forEach((t=>t.reset()))}addHelper(t=.1,e=.01){this.helper||(this.helper=new E({skeleton:this.skeleton,lineWidth:e,dotSize:t}),this.add(this.helper))}removeHelper(){this.helper&&(this.remove(this.helper),this.helper.dispose(),this.helper=null)}updateMatrixWorld(t){let e;if(super.updateMatrixWorld(t),this.ms){const t=performance.now();e=t-this.ms,e/=1e3,this.ms=t}else this.ms=performance.now(),e=.016;this.wiggleBones.forEach((t=>t.update(e)))}dispose(){this.removeHelper(),this.wiggleBones.forEach((t=>t.dispose())),this.wiggleBones=[],this.parent.remove(this)}}export{v as Spring,f as WiggleBone,C as WiggleGroup,B as WiggleRig,E as WiggleRigHelper,V as WiggleSpring};
